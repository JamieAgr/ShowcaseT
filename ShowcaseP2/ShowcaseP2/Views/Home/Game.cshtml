<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe</title>
    <link rel="stylesheet" href="~/css/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
</head>
<body>
    <div class="gamePage">
        <div class="board" id="main-board"></div>
        <div class="chat" id="chat">
            <!-- Chat messages go here -->
            <div class="chat-messages" id="chat-messages"></div>
            <div class="message-input">
                <input type="text" id="message-input" placeholder="Type your message...">
                <button id="send-button">Send</button>
            </div>
        </div>
    </div>

    <input type="hidden" id="validationURL" value="@Url.Action("ValidMove", "Game")" />
</body>
</html>




<script>
    var connection = new signalR.HubConnectionBuilder().withUrl("/hub").build();

    connection.start().catch(function (err) {
        return console.error(err.toString());
    });

    //document.addEventListener('DOMContentLoaded', function () {
    const mainBoard = document.getElementById('main-board');
    let currentPlayer = 'X'; // Player X starts
    let activeSubBoard = null; // Keep track of the active sub-board
    const chatMessages = document.getElementById('chat-messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');

    function createSubCell() {
        const subCell = document.createElement('div');
        subCell.classList.add('sub-cell', 'hoverable');
        return subCell;
    }

    function createSubBoard(i, j) {
        const subBoard = document.createElement('div');
        subBoard.classList.add('sub-board', `board-${i}-${j}`);
        subBoard.dataset.row = i;
        subBoard.dataset.col = j;

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const subCell = createSubCell();
                subCell.addEventListener('click', function () {
                    handleSubCellClick(subCell, i, j);
                });
                subBoard.appendChild(subCell);
            }
        }

        return subBoard;
    }

    function createCell(i, j) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        const subBoard = createSubBoard(i, j);
        cell.appendChild(subBoard);
        return cell;
    }

    function createMainBoard() {
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const cell = createCell(i, j);
                mainBoard.appendChild(cell);
            }
        }
    }

    async function handleSubCellClick(subCell, i, j) {
        if (!subCell.textContent && ((!activeSubBoard || subCell.parentElement === activeSubBoard) || activeSubBoard == null)) {
            const subBoard = subCell.parentElement;
            const row = subBoard.dataset.row;
            const col = subBoard.dataset.col;
            const cellRow = i % 3;
            const cellCol = j % 3;

            try {
                const response = await makeMove(row, col, cellRow, cellCol);
                const { winner, draw, currentPlayer: newPlayer, isMainBoardWon } = response;

                connection.invoke("MakeMove", parseInt(row), parseInt(col), parseInt(cellRow), parseInt(cellCol), !!winner)
                    .catch(function (err) {
                        return console.error(err.toString());
                    });

                if (isMainBoardWon) {
                    alert(`Main board is won by ${winner}!`); // Display an alert or any other UI indication
                }

                setBoardUI(cellRow, cellCol);

                connection.invoke("SetSubBoard").catch(function (err) {
                    return console.error(err.toString());
                })

                connection.invoke("SetCurrentPlayer").catch(function (err) {
                    return console.error(err.toString());
                })

            } catch (error) {
                console.error('Error making move:', error);
            }
        }
    }

    async function makeMove(row, col, cellRow, cellCol) {
        const response = await fetch('/game/move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ row, col, cellRow, cellCol })
        });
        if (!response.ok) {
            throw new Error('Failed to make move');
        }
        return await response.json();
    }

    function replaceSubBoardWithSymbol(subBoard, symbol) {
        const cell = subBoard.parentElement;
        if (symbol === 'draw') {
            //cell.textContent = 'Draw';
        } else {
            cell.removeChild(subBoard);
            cell.textContent = symbol;
        }
    }

    function extractBoardPosition(subBoard) {
        const className = subBoard.classList[1]; // Assuming the class follows the format "board-i-j"
        const [, boardRow, boardCol] = className.split('-');
        return [parseInt(boardRow), parseInt(boardCol)];
    }

    function setBoardUI(R, C) {
        activeSubBoard = null;
        if (R != -1) {
            const subBoards = document.querySelectorAll('.sub-board');
            subBoards.forEach(board => {
                const [boardRow, boardCol] = extractBoardPosition(board);
                if (boardRow === R && boardCol === C) {
                    activeSubBoard = board;
                    return;
                }
            });
        }

        // Reset border color for all subcells
        const allSubCells = document.querySelectorAll('.sub-cell');
        allSubCells.forEach(cell => {
            cell.style.borderColor = '';
        });

        // Set border color to green for subcells of active subboard
        const activeSubCells = activeSubBoard.querySelectorAll('.sub-cell');
        activeSubCells.forEach(cell => {
            cell.style.borderColor = 'green';
        });
    }

    createMainBoard();

    sendButton.addEventListener('click', async () => {
        const message = messageInput.value.trim();
        if (message !== '') {
            try {
                await connection.invoke("SendMessage", currentPlayer, message);
                messageInput.value =
                    messageInput.value = ''; // Clear the input field after sending message
            } catch (error) {
                console.error('Error sending message:', error);
            }
        }
    });

    connection.on("ReceiveMessage", function (player, message) {
        const messageElement = document.createElement('div');
        messageElement.textContent = `${player}: ${message}`;
        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    });


    connection.on("ReceiveMove", function (row, col, cellRow, cellCol, currentPlayer, winner) {
        const subBoards = document.querySelectorAll('.sub-board');
        subBoards.forEach(board => {
            const [boardRow, boardCol] = extractBoardPosition(board);
            if (boardRow == row && boardCol == col) {
                const subCells = board.querySelectorAll('.sub-cell');
                // Calculate the index of the subcell within the sub-board
                const subCellIndex = cellRow * 3 + cellCol;
                subCells[subCellIndex].textContent = currentPlayer;
                subCells[subCellIndex].classList.remove('hoverable');

                if (winner) {
                    console.log(subCells[subCellIndex].parentElement)
                    replaceSubBoardWithSymbol(subCells[subCellIndex].parentElement, currentPlayer);
                }
            }
        });
    });

    connection.on("GetSub", function (row, col) {
        setBoardUI(row, col);
    });

    connection.on("GetPlayer", function (player) {
        currentPlayer = player;
    });

    connection.on("Receive", function () {
        console.log("werkt")
    });
</script>
